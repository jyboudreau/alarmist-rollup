let combine,flatten,forEach,fromPromise,map,merge,pipe,scan,share,debounce,fromNodeEvent,distinctUntilChanged,of,watchFile,curry,tap,resolve,createRollupWatcher,loadRollup,yargs,createJob;_49d‍.w("callbag-basics",[["combine",["combine"],function(v){combine=v}],["flatten",["flatten"],function(v){flatten=v}],["forEach",["forEach"],function(v){forEach=v}],["fromPromise",["fromPromise"],function(v){fromPromise=v}],["map",["map"],function(v){map=v}],["merge",["merge"],function(v){merge=v}],["pipe",["pipe"],function(v){pipe=v}],["scan",["scan"],function(v){scan=v}],["share",["share"],function(v){share=v}]]);_49d‍.w("callbag-debounce",[["debounce",["debounce"],function(v){debounce=v}]]);_49d‍.w("callbag-from-events",[["default",["fromNodeEvent"],function(v){fromNodeEvent=v}]]);_49d‍.w("callbag-distinct-until-changed",[["default",["distinctUntilChanged"],function(v){distinctUntilChanged=v}]]);_49d‍.w("callbag-of",[["default",["of"],function(v){of=v}]]);_49d‍.w("chokidar",[["watch",["watchFile"],function(v){watchFile=v}]]);_49d‍.w("lodash/fp",[["curry",["curry"],function(v){curry=v}]]);_49d‍.w("callbag-tap",[["default",["tap"],function(v){tap=v}]]);_49d‍.w("path",[["resolve",["resolve"],function(v){resolve=v}]]);_49d‍.w("rollup",[["watch",["createRollupWatcher"],function(v){createRollupWatcher=v}]]);_49d‍.w("rollup/dist/loadConfigFile",[["default",["loadRollup"],function(v){loadRollup=v}]]);_49d‍.w("yargs",[["default",["yargs"],function(v){yargs=v}]]);_49d‍.w("alarmist",[["createJob",["createJob"],function(v){createJob=v}]]);













const argv = yargs.argv._

const logger = (title) => (...args) => _49d‍.g.console.log(title, ...args)
const log = logger('Log -> ')

log('Starting')

const configFile = argv[0]

const fileWatcher = watchFile(argv[0])

const fileReadyStream = fromNodeEvent(fileWatcher, 'ready')
const fileChangeStream = fromNodeEvent(fileWatcher, 'change')
const debouncedFileChangeStream = debounce(1000 /*msec*/)(fileChangeStream)

async function loadRollupConfig(configFile) {
  try {
    const payload = await loadRollup(resolve(configFile))
    return payload
  } catch (error) {
    return { error }
  }
}

const configStream = pipe(
  merge(fileReadyStream, debouncedFileChangeStream),
  map(() => fromPromise(loadRollupConfig(configFile))),
  flatten
)

const rollupWatcherStream = pipe(
  configStream,
  scan((rollupWatcher, { options, warnings }) => {
    // If there was already a rollup watcher, close it.
    log('Starting to create watcher')
    if (rollupWatcher) {
      log('Closing existing watcher')
      rollupWatcher.close()
    }
    const watcher = createRollupWatcher(options)

    // Attach the warnings to the watcher... such a weird interface.
    watcher.warnings = warnings

    return watcher
  }, undefined),
  share
)

const rollupEventStream = pipe(
  rollupWatcherStream,
  // Map the watcher to it's events. Need to combine the watcher as well to keep the context.
  map((watcher) => combine(of(watcher), fromNodeEvent(watcher, 'event'))),
  flatten
  //tap(logger('Event -> '))
)

// TODO: All these need to be parameters
const name = 'rollup'
const workingDir = '.alarmist'

const jobStream = pipe(
  rollupEventStream,
  scan(async (jobPromise, [watcher, event]) => {
    const job = jobPromise && (await jobPromise)

    switch (event.code) {
      case 'START':
        if (job) {
          job.end('aborted: new run started')
        }

        const newJob = await createJob({ name, workingDir })
        newJob.log.write('Started rollup build')
        return newJob
      case 'BUNDLE_START':
        job.log.write('Bundle start')
        break
      case 'BUNDLE_END':
        job.log.write('Bundle end')
        break
      case 'END':
        job.end()
        return undefined
      case 'ERROR':
        job.end('Rollup build failed')
        return undefined
      default:
        log('Error -> Wrong type of rollup event received')
    }

    return job
  }, undefined),
  distinctUntilChanged(),
  map(fromPromise),
  flatten
)

pipe(
  jobStream,

  forEach(logger('Drain -> '))
)

// watch({ configFile: argv[0] })
