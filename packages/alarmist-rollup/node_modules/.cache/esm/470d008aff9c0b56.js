let combine,flatten,forEach,fromPromise,map,merge,pipe,scan,share,debounce,fromNodeEvent,distinctUntilChanged,of,watchFile,curry,tap,resolve,dirname,relative,isAbsolute,createRollupWatcher,ROLLUP_VERSION,loadRollup,yargs,createJob,color,dateTime,util;_ff9‍.w("callbag-basics",[["combine",["combine"],function(v){combine=v}],["flatten",["flatten"],function(v){flatten=v}],["forEach",["forEach"],function(v){forEach=v}],["fromPromise",["fromPromise"],function(v){fromPromise=v}],["map",["map"],function(v){map=v}],["merge",["merge"],function(v){merge=v}],["pipe",["pipe"],function(v){pipe=v}],["scan",["scan"],function(v){scan=v}],["share",["share"],function(v){share=v}]]);_ff9‍.w("callbag-debounce",[["debounce",["debounce"],function(v){debounce=v}]]);_ff9‍.w("callbag-from-events",[["default",["fromNodeEvent"],function(v){fromNodeEvent=v}]]);_ff9‍.w("callbag-distinct-until-changed",[["default",["distinctUntilChanged"],function(v){distinctUntilChanged=v}]]);_ff9‍.w("callbag-of",[["default",["of"],function(v){of=v}]]);_ff9‍.w("chokidar",[["watch",["watchFile"],function(v){watchFile=v}]]);_ff9‍.w("lodash/fp",[["curry",["curry"],function(v){curry=v}]]);_ff9‍.w("callbag-tap",[["default",["tap"],function(v){tap=v}]]);_ff9‍.w("path",[["resolve",["resolve"],function(v){resolve=v}],["dirname",["dirname"],function(v){dirname=v}],["relative",["relative"],function(v){relative=v}],["isAbsolute",["isAbsolute"],function(v){isAbsolute=v}]]);_ff9‍.w("rollup",[["watch",["createRollupWatcher"],function(v){createRollupWatcher=v}],["VERSION",["ROLLUP_VERSION"],function(v){ROLLUP_VERSION=v}]]);_ff9‍.w("rollup/dist/loadRollupConfig",[["default",["loadRollup"],function(v){loadRollup=v}]]);_ff9‍.w("yargs",[["default",["yargs"],function(v){yargs=v}]]);_ff9‍.w("alarmist",[["createJob",["createJob"],function(v){createJob=v}]]);_ff9‍.w("colorette",[["default",["color"],function(v){color=v}]]);_ff9‍.w("date-time",[["default",["dateTime"],function(v){dateTime=v}]]);_ff9‍.w("util",[["default",["util"],function(v){util=v}]]);
















const argv = yargs.argv._

const logger = (title) => (...args) => _ff9‍.g.console.log(title, ...args)
const log = logger('Log -> ')

log('Starting')

const configFile = argv[0]
const fileWatcher = watchFile(argv[0])

const fileReadyStream = fromNodeEvent(fileWatcher, 'ready')
const fileChangeStream = fromNodeEvent(fileWatcher, 'change')
const debouncedFileChangeStream = debounce(1000 /*msec*/)(fileChangeStream)

async function loadRollupConfig(configFile) {
  try {
    return loadRollup(resolve(configFile))
  } catch (error) {
    return { error }
  }
}

const configStream = pipe(
  merge(fileReadyStream, debouncedFileChangeStream),
  map(() => fromPromise(loadRollupConfig(configFile))),
  flatten
)

const rollupWatcherStream = pipe(
  configStream,
  scan((rollupWatcher, { options, warnings }) => {
    // If there was already a rollup watcher, close it.
    log('Starting to create watcher')
    if (rollupWatcher) {
      log('Closing existing watcher')
      rollupWatcher.close()
    }
    const watcher = createRollupWatcher(options)

    // Attach the warnings to the watcher... such a weird interface.
    watcher.warnings = warnings

    return watcher
  }, undefined),
  share
)

function withRedirectedStdErr(func, redirect) {
  const oldWrite = process.stderr.write
  process.stderr.write = redirect

  func()

  process.stderr.write = oldWrite
}

const rollupEventStream = pipe(
  rollupWatcherStream,
  // Map the watcher to it's events. Need to combine the watcher as well to keep the context.
  map((watcher) => combine(fromNodeEvent(watcher, 'event'), of(watcher))),
  flatten,
  // Combine add the source to the event.
  map(([event, source]) => ({ ...event, source }))
)

const createJobRunner = () => {
  let jobPromise

  const end = async (...params) => {
    if (jobPromise) {
      const job = await jobPromise
      job.end(...params)
    }
    jobPromise = undefined
  }

  const start = async (params = {}) => {
    jobPromise = (async () => {
      await end(params.abortMessage || 'aborted: new run started')
      return createJob(params)
    })()

    return jobPromise
  }

  const write = async (params) => {
    if (jobPromise) {
      const job = await jobPromise
      job.log.write(`${params}\n`)
    } else {
      log('Attempt to write to non-existant job.')
    }
  }

  return {
    end,
    start,
    write,
  }
}

function relativeId(id) {
  if (!isAbsolute(id)) {
    return id
  }
  return relative(process.cwd(), id)
}

// TODO: All these need to be parameters
const name = 'rollup'
const workingDir = '.alarmist'
const jobRunner = createJobRunner()

pipe(
  rollupEventStream,
  forEach((event) => {
    switch (event.code) {
      case 'START':
        jobRunner.start({ name, workingDir })
        jobRunner.write(color.underline(`rollup v${ROLLUP_VERSION}`))
        break
      case 'BUNDLE_START':
        let { input } = event
        if (typeof input !== 'string') {
          input = Array.isArray(input) ? input.join(', ') : Object.values(input).join(', ')
        }

        jobRunner.write(
          color.cyan(`bundles ${color.bold(input)} → ${color.bold(event.output.map(relativeId).join(', '))}...`)
        )

        break
      case 'BUNDLE_END':
        withRedirectedStdErr(() => event.source.warnings.flush(), jobRunner.write)
        jobRunner.write(
          color.green(
            `created ${color.bold(event.output.map(relativeId).join(', '))} in ${color.bold(ms(event.duration))}`
          )
        )
        break
      case 'END':
        jobRunner.write(`\n[${dateTime()}] waiting for changes...`)
        jobRunner.end()
        break
      case 'ERROR':
        //TODO: Handle errors like in rollup
        withRedirectedStdErr(() => event.source.warnings.flush(), jobRunner.write)
        jobRunner.write('Rollup build failed')
        break
      default:
        log('Error -> Wrong type of rollup event received')
        break
    }
  })
)
